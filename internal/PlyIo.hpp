#ifndef PLYWRITER_H
#define PLYWRITER_H

#include <iostream>
#include <iomanip>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/io/ply_io.h>
#include <fstream>

// namespace of sensor calibration
namespace sc {

class PlyIo {
public:
	PlyIo() : file_(nullptr), initFlag_(false), pointNum_(0), typeByteSize_(0) {}

	PlyIo(const std::string& path) : initFlag_(false), pointNum_(0), typeByteSize_(0) {
		file_ = new std::ofstream(path, std::ios_base::out | std::ios_base::binary);
	}

	~PlyIo() { if (file_) delete file_; }

	bool Init(const std::string& path) {
		file_ = new std::ofstream(path, std::ios_base::out | std::ios_base::binary);
		return file_->is_open();
	}

	template <class T>
	bool SetOnePatch(pcl::PointCloud<T>& laserin) {
		if (!file_) {
			return false;
		}
		if (!initFlag_) {
			pcl::getFields<T>(fileds_);
			WriteHeader(file_, fileds_, typeByteSize_, 0);
			initFlag_ = true;
		}

		int pointByteSize = sizeof(T);
		int cloudSize = laserin.points.size();
		pointNum_ += cloudSize;
		
		char* buffer1 = new char[typeByteSize_];
		char* buffer2 = new char[pointByteSize];

		const auto& datas = laserin.points.data();
		for (int i = 0; i < cloudSize; i++) {
			int lastSize = 0;			
			memcpy(buffer2, datas + i, pointByteSize);

			for (const auto& field : fileds_) {
				int curSize = 0;
				switch (field.datatype) {
					case pcl::PCLPointField::INT8: curSize = 1; break;
					case pcl::PCLPointField::UINT8: curSize = 1; break;
					case pcl::PCLPointField::INT16: curSize = 2; break;
					case pcl::PCLPointField::UINT16: curSize = 2; break;
					case pcl::PCLPointField::INT32: curSize = 4; break;
					case pcl::PCLPointField::UINT32: curSize = 4; break;
					case pcl::PCLPointField::FLOAT32: curSize = 4; break;
					case pcl::PCLPointField::FLOAT64: curSize = 8; break;
					default: {
						return false;
					}
				}

				memcpy(buffer1 + lastSize, buffer2 + field.offset, curSize);
				lastSize += curSize;
			}

			file_->write(buffer1, typeByteSize_);
		}

		delete buffer1, buffer2;
		return true;
	}

	template <class T>
	static bool SavePLYFileBinary(const std::string& path, pcl::PointCloud<T>& cloud) {
		std::ofstream* ofs = new std::ofstream(path, std::ios_base::out | std::ios_base::binary);
		if (!ofs->is_open() || cloud.empty()) {
			return false;
		}

		int typeByteSize = 0, pointByteSize = sizeof(T);
		int cloudSize = cloud.points.size();

		std::vector<pcl::PCLPointField> fileds;
		pcl::getFields<T>(fileds);

		WriteHeader(ofs, fileds, typeByteSize, cloudSize);

		char* buffer = new char[typeByteSize];
		char* buffer2 = new char[pointByteSize];

		const auto& datas = cloud.points.data();
		for (int i = 0; i < cloudSize; i++) {
			int lastSize = 0;
			
			memcpy(buffer2, datas + i, pointByteSize);

			for (const auto& field : fileds) {
				int curSize = 0;
				switch (field.datatype) {
					case pcl::PCLPointField::INT8: curSize = 1; break;
					case pcl::PCLPointField::UINT8: curSize = 1; break;
					case pcl::PCLPointField::INT16: curSize = 2; break;
					case pcl::PCLPointField::UINT16: curSize = 2; break;
					case pcl::PCLPointField::INT32: curSize = 4; break;
					case pcl::PCLPointField::UINT32: curSize = 4; break;
					case pcl::PCLPointField::FLOAT32: curSize = 4; break;
					case pcl::PCLPointField::FLOAT64: curSize = 8; break;
					default: {
						return false;
					}
				}

				memcpy(buffer + lastSize, buffer2 + field.offset, curSize);
				lastSize += curSize;
			}

			ofs->write(buffer, typeByteSize);
		}

		Close(ofs, fileds, typeByteSize, cloudSize);
		ofs = NULL;
		delete buffer, buffer2;

		return true;
	}

	template <class T>
	static bool LoadPLYFile(const std::string& path, pcl::PointCloud<T>& cloud) {
		pcl::io::loadPLYFile(path, cloud);
		return !cloud.empty();
	}

	void Flush() {
		Flush(file_, fileds_, typeByteSize_, pointNum_);
	}

	void Close() {
		Close(file_, fileds_, typeByteSize_, pointNum_);
		file_ = NULL;
	}

private:
	static void WriteHeader(std::ofstream* ofs, const std::vector<pcl::PCLPointField> fileds, 
							 int& pointByteSize, const long long pointsNum = 0) {
		(*ofs) << "ply\n"
			<< "format binary_little_endian 1.0\n"
			<< "comment generated by GreenValley\n"
			<< "element vertex " << std::setw(15) << std::setfill('0')
			<< pointsNum;

		for (const auto& field : fileds) {
			if (field.name == "normal_x") {
				(*ofs) << "\nproperty float nx";
				pointByteSize += 4;
			}
			else if (field.name == "normal_y") {
				(*ofs) << "\nproperty float ny";
				pointByteSize += 4;
			}
			else if (field.name == "normal_z") {
				(*ofs) << "\nproperty float nz";
				pointByteSize += 4;
			}
			else if (field.name == "rgb") {
				(*ofs) << "\nproperty uchar red"
					"\nproperty uchar green"
					"\nproperty uchar blue";
				pointByteSize += 3;
			}
			else if (field.name == "rgba") {
				(*ofs) << "\nproperty uchar red"
					"\nproperty uchar green"
					"\nproperty uchar blue"
					"\nproperty uchar alpha";
				pointByteSize += 4;
			}
			else {
				(*ofs) << "\nproperty";
				if (field.count != 1)
					(*ofs) << " list uint";
				switch (field.datatype) {
				case pcl::PCLPointField::INT8: (*ofs) << " char "; pointByteSize += 1; break;
				case pcl::PCLPointField::UINT8: (*ofs) << " uchar "; pointByteSize += 1; break;
				case pcl::PCLPointField::INT16: (*ofs) << " short "; pointByteSize += 2; break;
				case pcl::PCLPointField::UINT16: (*ofs) << " ushort "; pointByteSize += 2; break;
				case pcl::PCLPointField::INT32: (*ofs) << " int "; pointByteSize += 4; break;
				case pcl::PCLPointField::UINT32: (*ofs) << " uint "; pointByteSize += 4; break;
				case pcl::PCLPointField::FLOAT32: (*ofs) << " float "; pointByteSize += 4; break;
				case pcl::PCLPointField::FLOAT64: (*ofs) << " double "; pointByteSize += 8; break;
				default: {
					std::cout << "Unknown data field type!\n";
					return;
				}
				}
				(*ofs) << field.name;
			}
		}
		(*ofs) << "\nend_header\n";
	}

	static void Flush(std::ofstream* ofs, const std::vector<pcl::PCLPointField> fileds,
					  int& pointByteSize, const long long pointsNum = 0) {
		if (ofs) {
			ofs->flush();
			std::streamoff pos = ofs->tellp();
			ofs->seekp(0);
			int pointByteSizeCopy = pointByteSize;
			WriteHeader(ofs, fileds, pointByteSizeCopy, pointsNum);
			ofs->seekp(pos);
		}
	}

	static void Close(std::ofstream* ofs, const std::vector<pcl::PCLPointField> fileds,
					  int& pointByteSize, const long long pointsNum = 0) {
		if (ofs) {
			ofs->flush();
			ofs->seekp(0);
			int pointByteSizeCopy = pointByteSize;
			WriteHeader(ofs, fileds, pointByteSizeCopy, pointsNum);
			ofs->close();
			delete ofs;
			ofs = NULL;
		}
	}

private:
	std::ofstream* file_;
	int pointNum_;
	bool initFlag_;
	std::vector<pcl::PCLPointField> fileds_;
	int typeByteSize_;
};

}// namespace sc


#endif

